
## 서문

일반적으로 소프트웨어 엔지니어링의 매력적인 측면 중 하나는 각각의 개념들이 얼마나 좋고 위대한가에 대한 것이지만

당시의 도구들과 관행을 통해서 재 창조 되어집니다.

대표적인 예가 마이크로서비스 패턴과 프랙티스입니다.

물론, 회의론자들은 마이크로서비스를 2000년대의 서비스 지향 아키텍처(SOA) 보다 좋지 않다고 할 수 있지만

현실은 마이크로서비스가 현대적인 개발, 테스트 및 배포 기술에서 나왔으며 오픈소스의 민주화에 의해 형성된 예라는 것입니다.

실제로 SOA에서 완성 된 마이크로서비스는 우리 산업을 변화시키고 있습니다.

DevOps방식을 통한 마이크로서비스 방식은 응용 프로그램 개발 속도를 훨씬 더 빠르게 만들어 줍니다.

결국 개발자들은 빠르게 변화하는 앱 기반 서비스와 애플리케이션의 세계에서 혁신을 가속화 하고 잠재적 경쟁 우위를 점할 수 있습니다.

마이크로서비스의 힘은 그들의 규범적이지 않은 성격으로부터 비롯 됩니다.

현대 웹에서 태어난 마이크로서비스는 단순한 얇은 API 레이어와 HTTP 언어를 사용하여 상호 연결 됩니다.

규범적인 산업 규격의 부재는 다양한 SOA 실무 경험이 있는 경우 많은 질문을 제기 할 수 있습니다.

때때로 "SOA가 잘했다"라고 알려졌지만 실제로 그런지와 마이크로서비스가 옳은 것은 무엇인지 알아 볼 필요가 있습니다.


## 1. 서비스 기반 아키텍처 (Service-Based-Architectures)

마이크로서비스 아키텍처와 SOA 모두 서비스 기반 아키텍처로 간주 됩니다.

즉, 비즈니스 및 비-비즈니스 기능을 구현 및 수행하는데 있어서 서비스 기반 아키텍처를 사용하고 있습니다.

마이크로서비스와 SOA는 매우 다른 아키텍처 스타일이지만 많은 특성을 공유합니다.

서비스 기반 아키텍처의 공통점은 아래와 같습니다.

* 일반적으로 분산 된 아키텍처이기에 서비스 구성 요소가 REST, SOAP, AMQP, JMS, MSMQ, RMI, .NET Remoting 과 같은 일종의 원격 액세스 프로토콜을 통해 원격으로 액세스 된다는 것입니다.

* 분산 아키텍처는 모놀리틱식 및 계층 기반 아키텍처(Layered-based-Architectures)에 비해 확장성이 뛰어나고 더 나은 디커플링, 개발, 테스트 및 배치에 대한 더 나은 제어 기능을 제공합니다.

서비스 기반 아키텍처에서 모듈성이란 응용 프로그램의 일부가 다른 구성요소나 서비스에 의존성이 적기 때문에 개별적으로 설계. 개발, 테스트 및 배포 할 수 있는 서비스로 캡슐화 하는 절차 입니다.

이러한 장점에도 불구하고 분산 아키텍처는 복잡성과 비용이 증가 되기 때문에 응답이 없는 서비스를 처리하거나 보안, 분산 트랜잭션과 같은 문제가 발생합니다.

### 1.1 Service Contracts

서비스 컨트랙트는 데이터를 계약 형식(XML, JSON, Java객체)으로 한 서비스 제공자와 소비자간의 일종의 계약입니다.

이러한 계약을 만들고 수정하는 것은 사후 검토로 다루어서는 안되는 중요하고 어려운 작업입니다.

서비스 기반 아키텍처에서는 아래와 같은 두 가지 기본 유형의 서비스 계약 모델이 존재합니다.

* 서비스기반 계약 - 서비스 제공자가 계약의 유일한 소유자이며 서비스 소비자의 요구를 고려하지 않고 일반적으로 계약을 자유롭게 변경 할 수 있습니다. 이러한 모델은 서비스 소비자가 새로운 서비스 기능을 필요로 하는지 여부에 관계 없이 소비자들은 서비스 제공자의 계약 변경을 체택하여야 합니다.

* 소비자 중심 계약 - 소비자 중심의 계약은 서비스 제공자와 소비자간의 긴밀한 관계를 기반으로 합니다. 이 모델을 사용하면 서비스 소유자와 서비스 소비자간에 강력한 협업이 이루어집니다. 서비스 소비자는 자유롭게 서비스 계약의 변경을 제안 할 수 있으며, 이런 경우 다른 서비스 소비자에게 미치는 영향에 따라서 거비 될 수 있습니다. 완벽한 시나리오는 서비스 소유자에게 테스트를 제공하므로 한 소비자가 변경을 제안할 경우 테스트를 통해서 다른 서비스 소비자에게도 영향이 미치는지 알 수 있습니다. 이러한 테스트를 지원해주는 오픈 소스 도구는 Pact와 Pacto 등이 존재합니다.

서비스 계약 안에서 또 다른 중요한 것은 버져닝입니다. 언젠가는 서비스 제공자와 서비스 소비자간의 계약이 변경 될 것입니다.
계약 버젼 관리를 사용하게 되면 계약 변경과 관련 된 새로운 기능을 롤아웃 할 수 있으며 동시에 이전 계약을 사용하고 있는 서비스 소비자에게 이전 버전과의 호환성을 제공할 수 있습니다.

동질적 버젼 관리는 동일한 서비스 계약에 버젼 번호를 사용하는 것을 의미합니다.

추가해야 함

### 1.2 Service Availability

서비스 가용성은 서비스 반응성과 함께 서비스 기반 아키텍처에서 고려되어야 하는 상황이지만 다른 개념입니다.

두 가지 모두 서비스 소비자가 서비스와 통신 할 수 있는 능력과 관련 되었지만 의미가 아래와 같이 다릅니다.

* 서비스 가용성 - 원격 서비스가 적시에 요청을 수용할 수 있는 능력

* 서비스 반응성 - 서비스 소비자가 서비스에서 적시에 응답을 받을 수 있는 능력

서비스 가용 실패와 서비스 반응 실패의 결과는 결국 동일합니다.(서비스 소비자에게 원하는 값을 줄 수 없음)

하지만 다른 방법으로 처리가 됩니다.

서비스 가용성은 서비스와 연결과 관련 되어 있기 때문에 서비스 소비자가 설정 된 횟수 만큼 연결을 다시 시도하거나 가능한 경우 나중에 처리하기 위해 요청을 대기열로 보내는 것 외에는 서비스 소비자가 할 수 있는 일이 거의 없습니다.

서비스 반응성에 대한 문제 해결은 더욱더 복잡합니다. 서비스에 요청을 성공적으로 보내면 응답을 받기 위해 얼마나 기다려야 하는지? 서비스가 단순히 느려진건지? 아니면 서비스에 무슨일이 생긴건지? 와 같은 문제점들이 있을 수 있습니다.

시간 초과 조건을 해결하는 것은 가장 어려운 측면 중 하나가 될 수 있습니다. 합리적인 시간 초과 값을 결정하는 일반적인 방법은 먼저 최대 응답시간을 얻기 위해 벤치마크를 설정한 다음 가변 부하 조건을 고려한 시간을 추가하는 것입니다.

예를 들어 벤치마크를 실행하고 특정 서비스 요청에 대한 응답시간이 2초임을 확인하였다면 제한시간을 초과하는 2배의 값 4초로 할 경우 문제를 해결 할 수 있습니다.

하지만 그럼에도 불구하고 서비스가 실제로 작동하지 않을 경우 모든 요청은 서비스가 응답하지 않는다고 판단하기 전에 몇 초 동안 기다려야 합니다. 이는 최종 사용자에게 있어서 매우 비효율적인 일입니다. 다른 문제는 벤치마크가 정확하지 않을 수 있으며 부하가 많은 경우 서비스 응답이 실제로 계산한 4초가 아니라 5초 일 수 있습니다. 이러한 경우는 서비스는 실제로 응답하지만 시간 초과 값이 너무 낮아서 모든 요청을 거부 할 수 있습니다.

이러한 문제를 해결하는 가장 인기 있는 기술은 회로 차단기(circuit breaker)입니다. 서비스가 적시에 응답이 없을 경우 타임아웃 값이 발생할 때까지 기다릴 필요 없이 회로 차단기가 회로를 차단해버립니다. 물리적 회로 차단기가 아닌 소프트웨어 회로 차단기이기에 스스로 재 설정할 수 있습니다.

이러한 대표적인 회로 차단기가 넷플릭스의 리본을 이용한 히스트릭스(Hystrix)입니다.

시간 초과 값을 처리 할 때 모든 요청에 대해 전역 시간 초과 값 사용을 피하는게 좋습니다.
대신 컨텍스트 기반 시간 제한 값을 사용하는 것을 고려하고 항상 응용프로그램을 다시 작성하고 배포할 필요 없이 다양한 부하 조건에 대해 신속하게 대응 가능하도록 외부에서 구성하는 것이 좋습니다.

또 다른 방법으로는 코드에 임베디드 된 "스마트 타임아웃 값"을 작성하여 조건에 따라 스스로 조정할 수 있습니다.
예를 들어, 응용 프로그램은 과부하 또는 네트워크 문제에 대한 응답으로 제한 시간 값을 자동으로 증가시킬 수 있습니다.
만약 로드가 감소하고 응답시간이 빨라짐에 따라 응용 프로그램은 특정 요청에 대한 평균 응답 시간을 계싼하고 이에 따라서 제한 시간 값을 낮출 수 있습니다.

### 1.3 Security

일반적으로 서비스 기반 아키텍처에서 대부분의 서비스들은 원격으로 액세스 되기 때문에 서비스 사용자가 특정 서비스에 액세스 가능하도록 하용하는 것이 중요합니다.

이 때, 서비스 사용자는 인증되어야 할 필요가 있습니다.
인증은 일반적으로 이름과 암호를 사용하여 연결 할 수 있는지 확인합니다.

물론 해당 사용자가 서비스에 연결 할 수 있다고 해서 서비스가 제공하는 모든 기능을 사용 할 수 있다는 뜻은 아닙니다.
따라서 권한 부여를 통해서 서비스 소비자가 서비스 내의 특정 비즈니스 기능에 액세스 할 수 있어야 합니다.

초기 SOA 구현 시 보안이 주요 문제였습니다. 안전한 사일로 기반 응용 프로그램에 있던 기능은 전 세계적으로 갑자기 엔터프라이즈 환경에 제공 되기 시작하였습니다.
이러한 문제는 서비스에 액세스 하지 않아야 하는 소비자로부터 보호하는 방법에 큰 변화를 가져왔습니다.

마이크로서비스 역시 미들웨어 구성요소가 보안 기반 기능을 처리하지 않기 때문에 보안 문제가 발생합니다.
대신 각 서비스는 자체적으로 보안을 처리하거나 경우에 따라 API 계층을 응용 프로그램의 보안 측면을 처리하기 위해 보다 똑똑하게 만들 수 있습니다.
하나의 설계 방법은 인증을 별도의 서비스에 위임하고 권한이 부연 된 사용자에 대한 책임을 주는 것입니다.
물론 외부의 보안 관련 서비스에게 위임할 수 있지만 외부 종속성으로 더 강력한 바운디드 컨텍스트를 만들기 위해 서비스 자체에 권한을 캡슐화 하는 것이 좋습니다.

### 1.4 Transactions

트랜잭션은 서비스 기반 아키텍처에서 가장 큰 문제중 하나입니다. 트랜잭션에 관련해서 이야기 할때 대부분의 비즈니스 응용 프로그램에서 볼 수 있는 ACID 트랜잭션을 의미합니다. 이러한 ACID(원자성, 일관성, 격리 및 내구성) 트랜잭션은 단일 요청 내에서 여러 데이터베이스 업데이트를 조정하여 데이터베이스 일관성을 유지하는데 사용되므로 처리 중에 오류가 발생하면 모든 데이터베이스 업데이트가 해당 요청에 대해 롤백 됩니다.

서비스 기반 아키텍처가 일반적으로 분산 아키텍처이기 때문에 여러 원격 서비스에 트랜잭션 컨텍스트를 전파하고 유지하는 것은 매우 어려운 일입니다.
!!그림추가

위의 그림과 같이 하나의 서비스 요청은 해당 요청을 완성시키기 위해서 여러개의 다른 서비스를 호출 할 수 있습니다.
X로 표기 된 이유는 해당 시나리오가 ACID 트랜잭션을 사용하는 것이 가능하지 않음을 나타냅니다.

트랜잭션 이슈는 마이크로서비스 아키텍처와 달리 일반적으로 SOA에서 더 많이 발생 됩니다.
단일 비즈니스 요청을 수행하는데 여러 서비스가 사용되기 때문입니다.

ACID 트랜잭션을 사용하는 대신 서비스 기반 아키텍처는 BASE 트랜잭션을 사용합니다.
BASE 트랜잭션은 기본 가용성, 유연한 상태 (원서에는 soft state) 및 최종 일관성을 포함하는 스타일의 집합입니다.
BASE 트랜잭션에 의존하는 분산 응용 프로그램은 모든 트랜잭션의 일관성보다는 데이터베이스의 궁극적인 일관성을 중요시 합니다.
대표적인 예가 ATM 입금입니다. ATM을 통해서 입금을 하게 되면 계좌에 입금액이 표시되는데 몇 분에서 몇 시간이 걸릴 수 있습니다.
다시 말해 돈은 이미 내 손에서 떠났지만 은행 계좌에 도달하지 않은 유연한 전이 상태가 존재합니다.
우리는 단지 언젠가는 은행의 나의 계좌에 돈이 도착할 것임을 알고 신뢰합니다.
배치 작업은 또한 때때로 전체적인 시스템 관점에서 보았을 때 궁극적인 일관성에 의존합니다.

서비스 기반 아키텍처의 세계로 전환하려면 트랜잭션과 일관성에 대한 사고 방식을 변경해야 합니다.
최종 일관성 및 유연한 상태를 의존하지 못하는 상황에서는 비즈니스 로직을 단일 서비스로 캡슐화 하여 ACID 트랜잭션을 사용해야 합니다.

이벤트 주도 기술을 활용하여 요청 상태가 일관성 있게 되었을 때 소비자에게 알림을 보낼 수 있습니다.
이러한 기술은 응용 프로그램에 상당한 복잡성을 추가하지만 BASE 트랜잭션이 사용 될 때 트랜잭션 상태를 관리하는데 도움을 줄 수 있습니다.

### 1.5 Too Much Complexity?

서비스 기반 아키텍처는 모놀리틱 응용 프로그램에 비해 크게 개선 되었지만 위에서 말했듯이 서비스 계약, 가용성, 보안 및 트랜잭션과 같은 고려사항이 존재합니다.
마이크로서비스나 SOA와 같은 서비스 기반 아키텍처 접근 방식으로 전환은 이러한 절충방식을 사용해야 합니다.
다시 말하면 이러한 기술 사용 없이 문제를 해결 할 수 없으면 서비스 기반 아키텍처 솔루션을 시작해서는 안됩니다.
서비스 기반 아키텍처를 사용하는 대부분의 팀은 오픈소스, 상용도구 및 여러 솔루션을 통해 문제를 해결할 수 있습니다.

"서비스 기반 아키텍처가 복잡한가요?" 라는 질문에 답은 "그렇습니다"입니다.
하지만 추가 된 복잡성으로 인하여 개발 팀의 생산성을 높이고 보다 안정적이고 강력한 응용 프로그램을 만들고 전체 비용을 줄이며 결과 적으로 출시일을 단축 할 수 있는 특성과 기능이 제공됩니다.


## 2. 서비스 특성 비교

SOA 를 위한 OASIS 참조 모델은 서비스에 대하여 "규정 된 인터페이스를 사용하고 지정된 제약 조건 및 정책과 일치해야 실행 되는 하나 이상의 기능에 대한 액세스를 가능하게 하는 메커니즘" 이라고 정의합니다.
즉, 서비스에는 비즈니스 기능이 있으며 잘 정의 된 인터페이스와 해당 서비스에 접근하기 위한 계약이 존재합니다.
이 정의에서 명시되지 않은 것은 서비스가 분류, 조직 소유권 및 서비스 크기에 기초하여 어떻게 추가로 정의 되는가 하는 것입니다.
이러한 서비스 특성을 이해하면 특정 아키텍처 패턴 내에서 서비스의 컨텍스트를 정의하는데 도움이 됩니다.

마이크로서비스와 SOA는 모두 서비스를 주요 아키텍처 구성 요소로 사용하지만 서비스 특성 측면에서 크게 다릅니다.
이 장에서는 서비스가 각 패턴(서비스 분류법) 내에서 어떻게 분류 되는지, 서비스 소유자가 서비스를 조절하는 방법, 그리고 마이크로서비스와 SOA간의 서비스 세분성 차이에 초점을 맞춤으로써 마이크로서비스와 SOA를 비교합니다.

### 2.1 Service Taxonomy(서비스 분류학)

서비스 분류학이라는 용어는 서비스가 아키텍처 내에서 어떻게 분류되는지를 나타냅니다.
서비스 분류에는 서비스 유형(service type)과 비지니스 영역(business area)의 두 가지 기본 유형이 존재합니다.

* 서비스 유형 분류 - 전반적인 아키텍처에서 서비스가 수행하는 역할 유형을 나타냅니다. 예를 들어 일부 서비스는 비즈니스 기능을 구현하지만 다른 서비스는 로깅 및 보안과 같은 일반적인 비즈니스 기능이 아닌 기능을 구현 할 수 있습니다.

* 비즈니스 영역 분류 - 보고, 거래, 처리 또는 주문 배송과 같은 특정 비즈니스 기능 영역과 관련하여 비즈니스 서비스가 수행하는 역할을 의미합니다.


서비스 유형 분류는 일반적으로 아키텍처 패턴 수준에서 정의되는 반면, 비즈니스 영역 분류는 아키텍처 구현 수준에서 정의 됩니다. 아키텍처 패턴은 서비스 유형을 정의하기 위한 좋은 기반과 출발점을 제공하지만 아키텍트들은 이를 자유롭게 수정하고 자신의 분류를 제시할 수 있습니다.
여기서는 아키텍처 패턴과 일반적으로 마이크로서비스 및 SOA에서 찾을 수 있는 서비스 유형에 중점을 두겠습니다.

마이크로 서비스 아키텍처는 서비스 유형 분류에 있어 제한적인 서비스 분류 체계를 가지고 있으며, 아래의 그림과 (!!그림 추가) 같이 두가지 서비스 유형으로 구성 됩니다.

* Functional 서비스 - 특정 비즈니스 운영 또는 기능을 지원하는 서비스이며 외부에서 액세스가 가능하며 일반적으로 다른 서비스와 공유가 되지 않습니다.

* 인프라 서비스 - 인증, 권한 부여, 로깅 및 모니터링과 같은 비 기능적 작업을 지원합니다. 외부 세계에 노출되지 않고 다른 서비스에 내부적으로만 사용되는 서비스로 Functional 서비스와 주요 차이점입니다.

SOA 내의 서비스 분류 체계는 마이크로서비스 분류법과 크게 다릅니다. SOA는 전반적인 아키텍처에서 서비스의 유형과 서비스의 역할 면에서 매우 명확하고 일반적인 서비스 분류법이 존재합니다. SOA 안에는 여러가지 서비스 유형이 있을 수 있지만, 기본적으로 아래 그림과 같이(!!그림 추가) 4가지 기본 유형을 정의합니다.

* Business 서비스 - 비즈니스 서비스는 엔터프라이즈 수준에서 수행되는 핵심 비즈니스 운영을 정의하는 추상화 된 고급 서비스 입니다. 추상적이기 때문에 구현이나 프로토콜이 없으며 대게 서비스 이름, 예상되는 입력 및 예상되는 출력만 포함이 됩니다. 선택적으로 이러한 서비스 유형에는 처리 단계 또는 서비스와 관련 된 특별 조정 규칙도 포함 될 수 있습니다. 일반적으로 XML, WSDL(Web Services Definition Language) 또는 BPEL(Business Process Execution Language)를 통해 나타납니다.
서비스가 비즈니스 서비스로 간주되어야 하는지를 결정하기 위한 좋은 테스트는 서비스 이름의 문맥 앞에 "우리가 XXX를 하고 있는가?" 라는 단어를 추가하는 것입니다. 예를 들어 우리는 "거래 처리"를 하고 있는가? 라고 말하면 비즈니스 서비스 후보자가 분명해집니다.
만약 해당 문장이 이상한 경우는 비즈니스 서비스에 대한 응답으로 호출 되는 구체적인 서비스가 됩니다.

* Enterprise 서비스 - 엔터프라이즈 서비스는 비즈니스 서비스가 정의한 기능을 구현하는 구체적인 서비스입니다. 위의 그림에서 볼 수 있듯이, 일반적으로 비즈니스 서비스와 이에 상응하는 구체적인 엔터프라이즈 서비스 구현을 연결하는 것은 미들웨어 구성요소입니다.
엔터프라이즈 서비스는 비즈니스 서비스와 일대일 또는 일대다 관계를 가질 수 있습니다. 프로그래밍 언어나 플래폼을 사용하여 작성하거나 상용 제품을 사용하여 구현할 수 있습니다. 엔터프라이즈 서비스의 고유한 특징 중 하나는 조직 전체에서 공유 된다는 점입니다. 엔터프라이즈 서비스는 일반적으로 특정 비즈니스 요청을 수행하기 위해 응용 프로그램 서비스 및 인프라 서비스에 의존하지만 특정 요청에 필요한 모든 비즈니스 기능이 해당 엔터프라이즈 서비스 내에 자체 포함 될 수 있습니다.

* Application 서비스 - 어플리케이션 서비스는 특정 응용 프로그램 컨텍스트에 바인딩 되는 세부적인 응용 프로그램 별 서비스입니다. 여기서는 엔터프라이즈 수준에서 찾을 수 없는 특정 비즈니스 기능을 제공합니다.

* Infrastructure 서비스 - 마이크로서비스와 마찬가지로 보안 및 로깅과 같은 비 기능적 태스크를 구현하는 서비스입니다. SOA에서 인프라 서비스는 어플리케이션 서비스 또는 엔터프라이즈 서비스에서 호출 할 수 있습니다.


아키텍트들은 위의 아키텍처 패턴의 일부인 표준 서비스 유형을 사용하거나 새로운 분류 체계를 만들 수 있습니다. 어떤 작업을 하든지 상관 없이 아키텍쳐에 대해 잘 정의하고 문서화 된 서비스 분류 체계를 갖춰야 합니다.





d
