# Microservices vs SOA


TODO 그림 추가 필요


해당 글은 https://www.nginx.com/resources/library/microservices-vs-soa/ 의 EBOOK을 번역한 내용입니다.

중간 중간 필요 없다고 생각 되는 부분은 빼기도 하였고

번역이 이상한 부분도 존재합니다. 따라서 조금 더 깊게 이해하시려면 원서를 보시길 바랍니다.


## 서문

일반적으로 소프트웨어 엔지니어링의 매력적인 측면 중 하나는 각각의 개념들이 얼마나 좋고 위대한가에 대한 것이지만

당시의 도구들과 관행을 통해서 재 창조 되어집니다.

대표적인 예가 마이크로서비스 패턴과 프랙티스입니다.

물론, 회의론자들은 마이크로서비스를 2000년대의 서비스 지향 아키텍처(SOA) 보다 좋지 않다고 할 수 있지만

현실은 마이크로서비스가 현대적인 개발, 테스트 및 배포 기술에서 나왔으며 오픈소스의 민주화에 의해 형성된 예라는 것입니다.

실제로 SOA에서 완성 된 마이크로서비스는 우리 산업을 변화시키고 있습니다.

DevOps방식을 통한 마이크로서비스 방식은 응용 프로그램 개발 속도를 훨씬 더 빠르게 만들어 줍니다.

결국 개발자들은 빠르게 변화하는 앱 기반 서비스와 애플리케이션의 세계에서 혁신을 가속화 하고 잠재적 경쟁 우위를 점할 수 있습니다.

마이크로서비스의 힘은 그들의 규범적이지 않은 성격으로부터 비롯 됩니다.

현대 웹에서 태어난 마이크로서비스는 단순한 얇은 API 레이어와 HTTP 언어를 사용하여 상호 연결 됩니다.

규범적인 산업 규격의 부재는 다양한 SOA 실무 경험이 있는 경우 많은 질문을 제기 할 수 있습니다.

때때로 "SOA가 잘했다"라고 알려졌지만 실제로 그런지와 마이크로서비스가 옳은 것은 무엇인지 알아 볼 필요가 있습니다.


## 1. 서비스 기반 아키텍처 (Service-Based-Architectures)

마이크로서비스 아키텍처와 SOA 모두 서비스 기반 아키텍처로 간주 됩니다.

즉, 비즈니스 및 비-비즈니스 기능을 구현 및 수행하는데 있어서 서비스 기반 아키텍처를 사용하고 있습니다.

마이크로서비스와 SOA는 매우 다른 아키텍처 스타일이지만 많은 특성을 공유합니다.

서비스 기반 아키텍처의 공통점은 아래와 같습니다.

* 일반적으로 분산 된 아키텍처이기에 서비스 구성 요소가 REST, SOAP, AMQP, JMS, MSMQ, RMI, .NET Remoting 과 같은 일종의 원격 액세스 프로토콜을 통해 원격으로 액세스 된다는 것입니다.

* 분산 아키텍처는 모놀리틱식 및 계층 기반 아키텍처(Layered-based-Architectures)에 비해 확장성이 뛰어나고 더 나은 디커플링, 개발, 테스트 및 배치에 대한 더 나은 제어 기능을 제공합니다.

서비스 기반 아키텍처에서 모듈성이란 응용 프로그램의 일부가 다른 구성요소나 서비스에 의존성이 적기 때문에 개별적으로 설계. 개발, 테스트 및 배포 할 수 있는 서비스로 캡슐화 하는 절차 입니다.

이러한 장점에도 불구하고 분산 아키텍처는 복잡성과 비용이 증가 되기 때문에 응답이 없는 서비스를 처리하거나 보안, 분산 트랜잭션과 같은 문제가 발생합니다.

### 1.1 Service Contracts

서비스 컨트랙트는 데이터를 계약 형식(XML, JSON, Java객체)으로 한 서비스 제공자와 소비자간의 일종의 계약입니다.

이러한 계약을 만들고 수정하는 것은 사후 검토로 다루어서는 안되는 중요하고 어려운 작업입니다.

서비스 기반 아키텍처에서는 아래와 같은 두 가지 기본 유형의 서비스 계약 모델이 존재합니다.

* 서비스기반 계약 - 서비스 제공자가 계약의 유일한 소유자이며 서비스 소비자의 요구를 고려하지 않고 일반적으로 계약을 자유롭게 변경 할 수 있습니다. 이러한 모델은 서비스 소비자가 새로운 서비스 기능을 필요로 하는지 여부에 관계 없이 소비자들은 서비스 제공자의 계약 변경을 체택하여야 합니다.

* 소비자 중심 계약 - 소비자 중심의 계약은 서비스 제공자와 소비자간의 긴밀한 관계를 기반으로 합니다. 이 모델을 사용하면 서비스 소유자와 서비스 소비자간에 강력한 협업이 이루어집니다. 서비스 소비자는 자유롭게 서비스 계약의 변경을 제안 할 수 있으며, 이런 경우 다른 서비스 소비자에게 미치는 영향에 따라서 거비 될 수 있습니다. 완벽한 시나리오는 서비스 소유자에게 테스트를 제공하므로 한 소비자가 변경을 제안할 경우 테스트를 통해서 다른 서비스 소비자에게도 영향이 미치는지 알 수 있습니다. 이러한 테스트를 지원해주는 오픈 소스 도구는 Pact와 Pacto 등이 존재합니다.

서비스 계약 안에서 또 다른 중요한 것은 버져닝입니다. 언젠가는 서비스 제공자와 서비스 소비자간의 계약이 변경 될 것입니다.
계약 버젼 관리를 사용하게 되면 계약 변경과 관련 된 새로운 기능을 롤아웃 할 수 있으며 동시에 이전 계약을 사용하고 있는 서비스 소비자에게 이전 버전과의 호환성을 제공할 수 있습니다.

동질적 버젼 관리는 동일한 서비스 계약에 버젼 번호를 사용하는 것을 의미합니다. 아래 그림에서(!!!그림 추가) 서비스 사용자 A와 서비스 사용자 B가 사용하는 계약은 동일한 계약이지만 다른 버전 번호를 사용하고 있습니다.
예를 들어 1.1에 수령자가 집에 없는 경우 배달을 어떻게 해야 할지에 대한 지시를 제공하는 추가 입력란이 생겼다면 원래 1.0은 delivery-instructions 필드를 선택적으로 만들면 호환성을 유지 할 수 있습니다.

이기종 버전관리에는 여러 유형의 계약을 지원하는 작업이 포함됩니다. 이 기술은 소비자 중심 계약 개념에 더욱더 가깝습니다. 즉 새로운 기능이 추가되면 새로운 계약이 생성이 됩니다. 아래 그림에서 (!!! 그림 추가) 서비스 소비자 A는 원으로 표시된 계약을 사용하여 통신하지만 서비스 소비자 B는 삼각형으로 표시된 전혀 다른 계약을 사용합니다.

서비스가 여러 버전의 계약을 지원해야 한다는 사고 방식을 유지하면 개발 팀은 다른 서비스 소비자와 기존 계약을 위반할 염려 없이 새로운 기능 및 기타 변경 사항을 신속하게 배포 할 수 있습니다. 다른 계약 유형에 대해 여러 버전 번호를 지원함으로써 이 두가지 기술을 결합 할 수도 있습니다.

서비스 소비자가 계약이 변경되거나 특정 버전이나 계약 유형이 더이상 지원되지 않음을 알 수 있도록 처음부터 탄탄한 커뮤니케이션 전략을 수립해야 합니다. 많은 상황에서 내부 및 외부 서비스 소모 장치의 수가 많기 때문에 실현 될 수 없습니다. 이러한 상황에서 통합 허브(메시징 미들웨어)는 서비스 계층과 서비스 소비자간에 서비스 계약을 변환하는 추상 계층을 제공함으로써 도움을 줄 수 있습니다.



### 1.2 Service Availability

서비스 가용성은 서비스 반응성과 함께 서비스 기반 아키텍처에서 고려되어야 하는 상황이지만 다른 개념입니다.

두 가지 모두 서비스 소비자가 서비스와 통신 할 수 있는 능력과 관련 되었지만 의미가 아래와 같이 다릅니다.

* 서비스 가용성 - 원격 서비스가 적시에 요청을 수용할 수 있는 능력

* 서비스 반응성 - 서비스 소비자가 서비스에서 적시에 응답을 받을 수 있는 능력

서비스 가용 실패와 서비스 반응 실패의 결과는 결국 동일합니다.(서비스 소비자에게 원하는 값을 줄 수 없음)

하지만 다른 방법으로 처리가 됩니다.

서비스 가용성은 서비스와 연결과 관련 되어 있기 때문에 서비스 소비자가 설정 된 횟수 만큼 연결을 다시 시도하거나 가능한 경우 나중에 처리하기 위해 요청을 대기열로 보내는 것 외에는 서비스 소비자가 할 수 있는 일이 거의 없습니다.

서비스 반응성에 대한 문제 해결은 더욱더 복잡합니다. 서비스에 요청을 성공적으로 보내면 응답을 받기 위해 얼마나 기다려야 하는지? 서비스가 단순히 느려진건지? 아니면 서비스에 무슨일이 생긴건지? 와 같은 문제점들이 있을 수 있습니다.

시간 초과 조건을 해결하는 것은 가장 어려운 측면 중 하나가 될 수 있습니다. 합리적인 시간 초과 값을 결정하는 일반적인 방법은 먼저 최대 응답시간을 얻기 위해 벤치마크를 설정한 다음 가변 부하 조건을 고려한 시간을 추가하는 것입니다.

예를 들어 벤치마크를 실행하고 특정 서비스 요청에 대한 응답시간이 2초임을 확인하였다면 제한시간을 초과하는 2배의 값 4초로 할 경우 문제를 해결 할 수 있습니다.

하지만 그럼에도 불구하고 서비스가 실제로 작동하지 않을 경우 모든 요청은 서비스가 응답하지 않는다고 판단하기 전에 몇 초 동안 기다려야 합니다. 이는 최종 사용자에게 있어서 매우 비효율적인 일입니다. 다른 문제는 벤치마크가 정확하지 않을 수 있으며 부하가 많은 경우 서비스 응답이 실제로 계산한 4초가 아니라 5초 일 수 있습니다. 이러한 경우는 서비스는 실제로 응답하지만 시간 초과 값이 너무 낮아서 모든 요청을 거부 할 수 있습니다.

이러한 문제를 해결하는 가장 인기 있는 기술은 회로 차단기(circuit breaker)입니다. 서비스가 적시에 응답이 없을 경우 타임아웃 값이 발생할 때까지 기다릴 필요 없이 회로 차단기가 회로를 차단해버립니다. 물리적 회로 차단기가 아닌 소프트웨어 회로 차단기이기에 스스로 재 설정할 수 있습니다.

이러한 대표적인 회로 차단기가 넷플릭스의 리본을 이용한 히스트릭스(Hystrix)입니다.

시간 초과 값을 처리 할 때 모든 요청에 대해 전역 시간 초과 값 사용을 피하는게 좋습니다.
대신 컨텍스트 기반 시간 제한 값을 사용하는 것을 고려하고 항상 응용프로그램을 다시 작성하고 배포할 필요 없이 다양한 부하 조건에 대해 신속하게 대응 가능하도록 외부에서 구성하는 것이 좋습니다.

또 다른 방법으로는 코드에 임베디드 된 "스마트 타임아웃 값"을 작성하여 조건에 따라 스스로 조정할 수 있습니다.
예를 들어, 응용 프로그램은 과부하 또는 네트워크 문제에 대한 응답으로 제한 시간 값을 자동으로 증가시킬 수 있습니다.
만약 로드가 감소하고 응답시간이 빨라짐에 따라 응용 프로그램은 특정 요청에 대한 평균 응답 시간을 계싼하고 이에 따라서 제한 시간 값을 낮출 수 있습니다.

### 1.3 Security

일반적으로 서비스 기반 아키텍처에서 대부분의 서비스들은 원격으로 액세스 되기 때문에 서비스 사용자가 특정 서비스에 액세스 가능하도록 하용하는 것이 중요합니다.

이 때, 서비스 사용자는 인증되어야 할 필요가 있습니다.
인증은 일반적으로 이름과 암호를 사용하여 연결 할 수 있는지 확인합니다.

물론 해당 사용자가 서비스에 연결 할 수 있다고 해서 서비스가 제공하는 모든 기능을 사용 할 수 있다는 뜻은 아닙니다.
따라서 권한 부여를 통해서 서비스 소비자가 서비스 내의 특정 비즈니스 기능에 액세스 할 수 있어야 합니다.

초기 SOA 구현 시 보안이 주요 문제였습니다. 안전한 사일로 기반 응용 프로그램에 있던 기능은 전 세계적으로 갑자기 엔터프라이즈 환경에 제공 되기 시작하였습니다.
이러한 문제는 서비스에 액세스 하지 않아야 하는 소비자로부터 보호하는 방법에 큰 변화를 가져왔습니다.

마이크로서비스 역시 미들웨어 구성요소가 보안 기반 기능을 처리하지 않기 때문에 보안 문제가 발생합니다.
대신 각 서비스는 자체적으로 보안을 처리하거나 경우에 따라 API 계층을 응용 프로그램의 보안 측면을 처리하기 위해 보다 똑똑하게 만들 수 있습니다.
하나의 설계 방법은 인증을 별도의 서비스에 위임하고 권한이 부연 된 사용자에 대한 책임을 주는 것입니다.
물론 외부의 보안 관련 서비스에게 위임할 수 있지만 외부 종속성으로 더 강력한 바운디드 컨텍스트를 만들기 위해 서비스 자체에 권한을 캡슐화 하는 것이 좋습니다.

### 1.4 Transactions

트랜잭션은 서비스 기반 아키텍처에서 가장 큰 문제중 하나입니다. 트랜잭션에 관련해서 이야기 할때 대부분의 비즈니스 응용 프로그램에서 볼 수 있는 ACID 트랜잭션을 의미합니다. 이러한 ACID(원자성, 일관성, 격리 및 내구성) 트랜잭션은 단일 요청 내에서 여러 데이터베이스 업데이트를 조정하여 데이터베이스 일관성을 유지하는데 사용되므로 처리 중에 오류가 발생하면 모든 데이터베이스 업데이트가 해당 요청에 대해 롤백 됩니다.

서비스 기반 아키텍처가 일반적으로 분산 아키텍처이기 때문에 여러 원격 서비스에 트랜잭션 컨텍스트를 전파하고 유지하는 것은 매우 어려운 일입니다.
!!그림추가

위의 그림과 같이 하나의 서비스 요청은 해당 요청을 완성시키기 위해서 여러개의 다른 서비스를 호출 할 수 있습니다.
X로 표기 된 이유는 해당 시나리오가 ACID 트랜잭션을 사용하는 것이 가능하지 않음을 나타냅니다.

트랜잭션 이슈는 마이크로서비스 아키텍처와 달리 일반적으로 SOA에서 더 많이 발생 됩니다.
단일 비즈니스 요청을 수행하는데 여러 서비스가 사용되기 때문입니다.

ACID 트랜잭션을 사용하는 대신 서비스 기반 아키텍처는 BASE 트랜잭션을 사용합니다.
BASE 트랜잭션은 기본 가용성, 유연한 상태 (원서에는 soft state) 및 최종 일관성을 포함하는 스타일의 집합입니다.
BASE 트랜잭션에 의존하는 분산 응용 프로그램은 모든 트랜잭션의 일관성보다는 데이터베이스의 궁극적인 일관성을 중요시 합니다.
대표적인 예가 ATM 입금입니다. ATM을 통해서 입금을 하게 되면 계좌에 입금액이 표시되는데 몇 분에서 몇 시간이 걸릴 수 있습니다.
다시 말해 돈은 이미 내 손에서 떠났지만 은행 계좌에 도달하지 않은 유연한 전이 상태가 존재합니다.
우리는 단지 언젠가는 은행의 나의 계좌에 돈이 도착할 것임을 알고 신뢰합니다.
배치 작업은 또한 때때로 전체적인 시스템 관점에서 보았을 때 궁극적인 일관성에 의존합니다.

서비스 기반 아키텍처의 세계로 전환하려면 트랜잭션과 일관성에 대한 사고 방식을 변경해야 합니다.
최종 일관성 및 유연한 상태를 의존하지 못하는 상황에서는 비즈니스 로직을 단일 서비스로 캡슐화 하여 ACID 트랜잭션을 사용해야 합니다.

이벤트 주도 기술을 활용하여 요청 상태가 일관성 있게 되었을 때 소비자에게 알림을 보낼 수 있습니다.
이러한 기술은 응용 프로그램에 상당한 복잡성을 추가하지만 BASE 트랜잭션이 사용 될 때 트랜잭션 상태를 관리하는데 도움을 줄 수 있습니다.

### 1.5 Too Much Complexity?

서비스 기반 아키텍처는 모놀리틱 응용 프로그램에 비해 크게 개선 되었지만 위에서 말했듯이 서비스 계약, 가용성, 보안 및 트랜잭션과 같은 고려사항이 존재합니다.
마이크로서비스나 SOA와 같은 서비스 기반 아키텍처 접근 방식으로 전환은 이러한 절충방식을 사용해야 합니다.
다시 말하면 이러한 기술 사용 없이 문제를 해결 할 수 없으면 서비스 기반 아키텍처 솔루션을 시작해서는 안됩니다.
서비스 기반 아키텍처를 사용하는 대부분의 팀은 오픈소스, 상용도구 및 여러 솔루션을 통해 문제를 해결할 수 있습니다.

"서비스 기반 아키텍처가 복잡한가요?" 라는 질문에 답은 "그렇습니다"입니다.
하지만 추가 된 복잡성으로 인하여 개발 팀의 생산성을 높이고 보다 안정적이고 강력한 응용 프로그램을 만들고 전체 비용을 줄이며 결과 적으로 출시일을 단축 할 수 있는 특성과 기능이 제공됩니다.


## 2. 서비스 특성 비교

SOA 를 위한 OASIS 참조 모델은 서비스에 대하여 "규정 된 인터페이스를 사용하고 지정된 제약 조건 및 정책과 일치해야 실행 되는 하나 이상의 기능에 대한 액세스를 가능하게 하는 메커니즘" 이라고 정의합니다.
즉, 서비스에는 비즈니스 기능이 있으며 잘 정의 된 인터페이스와 해당 서비스에 접근하기 위한 계약이 존재합니다.
이 정의에서 명시되지 않은 것은 서비스가 분류, 조직 소유권 및 서비스 크기에 기초하여 어떻게 추가로 정의 되는가 하는 것입니다.
이러한 서비스 특성을 이해하면 특정 아키텍처 패턴 내에서 서비스의 컨텍스트를 정의하는데 도움이 됩니다.

마이크로서비스와 SOA는 모두 서비스를 주요 아키텍처 구성 요소로 사용하지만 서비스 특성 측면에서 크게 다릅니다.
이 장에서는 서비스가 각 패턴(서비스 분류법) 내에서 어떻게 분류 되는지, 서비스 소유자가 서비스를 조절하는 방법, 그리고 마이크로서비스와 SOA간의 서비스 세분성 차이에 초점을 맞춤으로써 마이크로서비스와 SOA를 비교합니다.

### 2.1 Service Taxonomy(서비스 분류학)

서비스 분류학이라는 용어는 서비스가 아키텍처 내에서 어떻게 분류되는지를 나타냅니다.
서비스 분류에는 서비스 유형(service type)과 비지니스 영역(business area)의 두 가지 기본 유형이 존재합니다.

* 서비스 유형 분류 - 전반적인 아키텍처에서 서비스가 수행하는 역할 유형을 나타냅니다. 예를 들어 일부 서비스는 비즈니스 기능을 구현하지만 다른 서비스는 로깅 및 보안과 같은 일반적인 비즈니스 기능이 아닌 기능을 구현 할 수 있습니다.

* 비즈니스 영역 분류 - 보고, 거래, 처리 또는 주문 배송과 같은 특정 비즈니스 기능 영역과 관련하여 비즈니스 서비스가 수행하는 역할을 의미합니다.


서비스 유형 분류는 일반적으로 아키텍처 패턴 수준에서 정의되는 반면, 비즈니스 영역 분류는 아키텍처 구현 수준에서 정의 됩니다. 아키텍처 패턴은 서비스 유형을 정의하기 위한 좋은 기반과 출발점을 제공하지만 아키텍트들은 이를 자유롭게 수정하고 자신의 분류를 제시할 수 있습니다.
여기서는 아키텍처 패턴과 일반적으로 마이크로서비스 및 SOA에서 찾을 수 있는 서비스 유형에 중점을 두겠습니다.

마이크로 서비스 아키텍처는 서비스 유형 분류에 있어 제한적인 서비스 분류 체계를 가지고 있으며, 아래의 그림과 (!!그림 추가) 같이 두가지 서비스 유형으로 구성 됩니다.

* Functional 서비스 - 특정 비즈니스 운영 또는 기능을 지원하는 서비스이며 외부에서 액세스가 가능하며 일반적으로 다른 서비스와 공유가 되지 않습니다.

* 인프라 서비스 - 인증, 권한 부여, 로깅 및 모니터링과 같은 비 기능적 작업을 지원합니다. 외부 세계에 노출되지 않고 다른 서비스에 내부적으로만 사용되는 서비스로 Functional 서비스와 주요 차이점입니다.

SOA 내의 서비스 분류 체계는 마이크로서비스 분류법과 크게 다릅니다. SOA는 전반적인 아키텍처에서 서비스의 유형과 서비스의 역할 면에서 매우 명확하고 일반적인 서비스 분류법이 존재합니다. SOA 안에는 여러가지 서비스 유형이 있을 수 있지만, 기본적으로 아래 그림과 같이(!!그림 추가) 4가지 기본 유형을 정의합니다.

* Business 서비스 - 비즈니스 서비스는 엔터프라이즈 수준에서 수행되는 핵심 비즈니스 운영을 정의하는 추상화 된 고급 서비스 입니다. 추상적이기 때문에 구현이나 프로토콜이 없으며 대게 서비스 이름, 예상되는 입력 및 예상되는 출력만 포함이 됩니다. 선택적으로 이러한 서비스 유형에는 처리 단계 또는 서비스와 관련 된 특별 조정 규칙도 포함 될 수 있습니다. 일반적으로 XML, WSDL(Web Services Definition Language) 또는 BPEL(Business Process Execution Language)를 통해 나타납니다.
서비스가 비즈니스 서비스로 간주되어야 하는지를 결정하기 위한 좋은 테스트는 서비스 이름의 문맥 앞에 "우리가 XXX를 하고 있는가?" 라는 단어를 추가하는 것입니다. 예를 들어 우리는 "거래 처리"를 하고 있는가? 라고 말하면 비즈니스 서비스 후보자가 분명해집니다.
만약 해당 문장이 이상한 경우는 비즈니스 서비스에 대한 응답으로 호출 되는 구체적인 서비스가 됩니다.

* Enterprise 서비스 - 엔터프라이즈 서비스는 비즈니스 서비스가 정의한 기능을 구현하는 구체적인 서비스입니다. 위의 그림에서 볼 수 있듯이, 일반적으로 비즈니스 서비스와 이에 상응하는 구체적인 엔터프라이즈 서비스 구현을 연결하는 것은 미들웨어 구성요소입니다.
엔터프라이즈 서비스는 비즈니스 서비스와 일대일 또는 일대다 관계를 가질 수 있습니다. 프로그래밍 언어나 플래폼을 사용하여 작성하거나 상용 제품을 사용하여 구현할 수 있습니다. 엔터프라이즈 서비스의 고유한 특징 중 하나는 조직 전체에서 공유 된다는 점입니다. 엔터프라이즈 서비스는 일반적으로 특정 비즈니스 요청을 수행하기 위해 응용 프로그램 서비스 및 인프라 서비스에 의존하지만 특정 요청에 필요한 모든 비즈니스 기능이 해당 엔터프라이즈 서비스 내에 자체 포함 될 수 있습니다.

* Application 서비스 - 어플리케이션 서비스는 특정 응용 프로그램 컨텍스트에 바인딩 되는 세부적인 응용 프로그램 별 서비스입니다. 여기서는 엔터프라이즈 수준에서 찾을 수 없는 특정 비즈니스 기능을 제공합니다.

* Infrastructure 서비스 - 마이크로서비스와 마찬가지로 보안 및 로깅과 같은 비 기능적 태스크를 구현하는 서비스입니다. SOA에서 인프라 서비스는 어플리케이션 서비스 또는 엔터프라이즈 서비스에서 호출 할 수 있습니다.


아키텍트들은 위의 아키텍처 패턴의 일부인 표준 서비스 유형을 사용하거나 새로운 분류 체계를 만들 수 있습니다. 어떤 작업을 하든지 상관 없이 아키텍쳐에 대해 잘 정의하고 문서화 된 서비스 분류 체계를 갖춰야 합니다.


### 2.2 서비스 소유권 및 협업 (Service Ownership and Coordination)

서비스 소유자는 서비스를 작성하고 유지 관리하는 조직내의 그룹 유형입니다. 마이크로서비스 아키텍처는 서비스 분류체계가 제한 되어 있기 때문에 응용 프로그램 개발 팀이 인프라 및 기능 서비스를 모두 소유하는 것이 일반적입니다.

수십 개의 응용 프로그램 개발 팀이 서비스를 작성하고 있을지라도 여기서 중요한 점은 모두가 동일한 유형의 그룹(응용 프로그램 개발 팀)에 속하는 것입니다.

아래 그림은 마이크로 서비스를 위한 전형적인 서비스 소유권 모델입니다. (!! 그림추가)

SOA에서는 일반적으로 각 서비스 유형마다 다른 서비스 소유자가 있습니다.
비즈니스 서비스는 일반적으로 비즈니스 사용자가 소유하고 엔터프라이즈 서비스는 일반적으로 공통(shared) 서비스 팀이나 설계자가 소유합니다. 응용 프로그램 서비스는 일반적으로 응용 프로그램 개발팀에서 소유하며 인프라 서비스는 응용 프로그램 개발팀 또는 인프라 서비스 팀이 소유 합니다. 공식적인 서비스는 아니지만 미들웨어 구성 요소는 일반적으로 통합 아키텍트 또는 미들웨어 팀이 소유합니다.

아래 그림은 SOA에 대한 전형적인 서비스 소유권 모델을 나타냅니다. (!! 그림 추가)


서비스 소유자의 중요성은 전반적인 서비스 협업의 중요성입니다.
SOA에서 단일 비즈니스 요청을 작성하거나 유지 관리하려면 여러 그룹과 협동을 해야 합니다.
비즈니스 사용자는 추상 비즈니스 서비스에 대해 자문을 받아야 하며, 비즈니스 서비스를 구현하기 위해 생성 된 엔터프라이즈 서비스에 대해 공유 서비스 팀과 상의를 해야 하며, 엔터프라이즈 서비스가 하위 수준의 기능을 호출 할 수 있도록 응용 프로그램 개발 팀과 협업을 해야 하며, 인프라 서비스를 통해 비 기능 요구 사항을 충족 시키려면 인프라팀과 협업을 해야 합니다. 마지막으로 메시징 미들웨어를 관리하는 미들웨어 팀 또는 통합 아키텍트와 협업을 해야 합니다.

반면에 마이크로 서비스의 경우 단일 비즈니스 요청을 수행하기 위한 서비스가 조정 될 필요가 없습니다. 서비스 소유자간에 조정이 필요하면 작은 응용 프로그램 개발 팀을 통해 신속하고 효율적으로 수행 됩니다.


서비스 소유권 및 전체 조정에 있어서 마이크로서비스와 SOA의 이러한 차이점은 서비스를 개발, 테스트, 배포 및 유지 관리하는데 소요되는 노력과 시간과 직결 됩니다. 마이크로서비스는 크기가 작고 다른 그룹과의 조정이 필요 없기 때문에 효과적인 배포 파이프 라인을 통해 서비스를 신속하게 개발, 테스트 및 배포 할 수 있습니다. 즉, 시간 단축, 개발 및 유지 보수 비용 절감, 견고한 응용 프로그램 개발이 가능합니다.


### 2.3 Service Granularity(서비스 세분성)

서비스 관점에서 마이크로서비스와 SOA의 가장 큰 차이점은 세분성입니다.
마이크로서비스는 이름에서 알 수 있듯이 작고 세분화 된 서비스입니다.
조금 더 구체적으로 말하면, 마이크로서비스는 아키텍처 내의 서비스 구성 요소는 일반적으로 단일 용도의 서비스입니다.
즉, 실제로 한가지를 수행합니다.

반면 SOA를 사용하면 서비스 구성요소는 소규모 응용프로그램 서비스에서 대규모 엔터프라이즈 서비스에 이르기까지 다양한 범위의 크기를 가질 수 있습니다. 실제로 SOA 내의 서비스 구성 요소를 대형 제품 또는 서브 시스템으로 표현하는 것이 일반적입니다.

흥미롭게도 원래 SOA에 직면한 가장 큰 도전 중 하나는 서비스 세분성이었습니다. 아키텍트는 세밀한 세분화의 영향을 이해하지 못하여 너무 세분화된 서비스를 자주 설계하여 성능 저하를 초래하였습니다.

마이크로서비스의 경우, 서비스 구성요소 기능이 매우 작은 경향이 있습니다. 심지어 한 두개의 모듈을 통해서만 구현이 될 때도 존재합니다.
반면 SOA의 경우 훨씬 더 많은 비즈니스 기능을 포함하는 경향이 존재합니다. 때로는 완전한 하위 시스템으로 구현 되기도 합니다.

일반적으로 SOA는 단일 비즈니스 요청을 완료하기 위해 여러 서비스에 의존하는 반면, 마이크로 서비스 아키텍처에서는 그러지 않습니다.

마이크로서비스 아키텍처 또는 SOA를 사용하는 경우 올바른 수준의 세밀성으로 서비스를 설계하는 것은 쉬운 일이 아닙니다.

서비스 세분화는 성능 및 트랜잭션 관리에 모두 영향을 미치고 있습니다. 너무 세분화 된 서비스는 단일 비즈니스 요청을 이행하기 위해 서비스간 통신이 필요하므로 수 많은 원격 서비스 호출이 발생합니다.
예를 들어 특정 사용자 요청을 처리하기 위해 네 가지 서비스가 필요하고 각 서비스간 통신이 100밀리초가 소요 된다고 가정할 경우 아래 그림처럼(!!그림 추가) 총 600밀리 초가 전송 시간에만 사용됩니다. 하지만 이러한 서비스를 단일 선비스로 통합하면 전송시간이 200밀리초로 단축 되어 0.5초 가까이 단축이 가능합니다.

트랜잭션 관리는 서비스 세분화의 영향을 받게 됩니다. 이전에 설명한 BASE트랜잭션이 아니라 ACID 트랜잭션일 때 나타납니다.
아래 그림의 첫번째 다이어그램에 표시 된 것처럼 서비스가 너무 세분화 된 경우 단일 트랜잭션 작업 단위를 사용할 수 없습니다. 하지만 이러한 서비스를 하나의 대형 원격 서비스로 결합 할 경우 아래 처럼 하나의 트랜잭션을 이용할 수 있습니다.

서비스 세분성을 다룰 때 일반적으로는 큰 서비스에서 작은 서비스로 분해하는 것이 좋습니다.
Sam Newman이 Building Microservices에서 다음과 같이 말을 하였습니다.
"작은 수의 대규모 서비스로 시작을 하십시오". 트랜잭션 문제와 마이크로서비스에서 많은 통신을 주의해야 합니다.

### 2.4 Granularity and Pattern Selection (세분성 및 패턴 선택)

서비스 세분성은 상황에 가장 적합한 아키텍처 패턴의 선택에 가장 큰 영향을 끼칩니다.
마이크로 서비스 내의 매우 작고 세분화 된 서비스 개념을 통해 아키텍처 패턴이 개발, 테스트, 배치 및 유지보수를 포함한 라이프사이클의 모든 측면을 개선 할 수 있도록 합니다. 굵직한 서비스를 사용할 경우 성능 및 트랜잭션 문제가 확실히 해결 될 수 있지만 개발, 테스트, 배포 및 유지 관리에 나쁜 영향을 미칠 수 있습니다.

만약 서비스 규모가 작은 것부터 큰 것까지 다양하다면 간단한 마이크로서비스 아키텍처 패턴보다는 SOA 패턴을 고려해야 할 수도 있습니다.
반면 비즈니스 기능을 매우 작고 독립적인 부분으로 나눌 수 있다면 마이크로서비스 패턴이 좋은 후보가 될 수 있습니다.


## 3. 아키텍처 특성 비교

컴포넌트는 잘 정의 된 인터페이스와 잘 정의 된 일련의 역할과 책임이 있는 소프트웨어 단위입니다.
이러한 컴포넌트들은 아키텍처의 블록을 형성합니다. 서비스 기반 아키텍처의 경우 이러한 빌딩 블록을 서비스라고 표현합니다.
아키텍처를 만들 때, 컴포넌트 공유 방법, 통신 방법, 특정 비즈니스 요청을 이행하기 위해서 조화되는 방법, 그리고 그것들이 소비자들로부터 어떻게 접속 되는지를 결정해야 합니다.

이러한 것들을 결정하는 것이 항상 쉬운 일은 아닙니다. 이러한 것들은 아키텍처 패턴에 나타납니다. 각 아키텍처 패턴에는 구성요소가 통신하고 함께 작동하는 방식을 비롯하여 아키텍처의 모양과 일반적인 특성을 정의하는 고유한 체계적인 분류(토폴로지)가 있습니다. 아키텍처 패턴의 토폴로지를 분석하면, 어떤 패턴이 더 적합한지 판단 할 수 있습니다.

이 장에서는 전반적인 아키텍처 토폴로지와 아키텍처 패턴의 특성 면에서 마이크로서비스와 SOA의 차이점을 살펴 봅니다.
특히, 서비스 구성 요소 공유 수준, 서비스 구성 요소 통신 수준 및 원격 서비스 구성 요소가 일반적으로 액세스 되는 방식과 관련하여 두가지 패턴의 차이점에 초점을 맞추고 있습니다.
또한 SOA아키텍처 패턴에서 존재하는 메시징 미들웨어와 마이크로서비스 아키텍처 패턴에 존재하는 선택적 API 계층 간의 차이점에 대해서도 살펴 보겠습니다.

### 3.1 Component Sharing

마이크로서비스와 SOA는 구성 요소를 공유하는 방법이 아래와 같이 본질적으로 다릅니다.

* SOA - "share-as-much-as-possible"

* 마이크로서비스 - "share-as-little-as-possible"

SOA에서 컴포넌트 공유는 핵심 방침(원서에는 tenets) 중 하나입니다. 실제로 컴포넌트 공유는 엔터프라이즈 서비스가 지향하는 것입니다.
예를 들어, 아래 그림과 같이 (!!그림추가) 고객 관리 시스템, 창고 관리 시스템 및 주분 이행 시스템과 같은 주문 처리와 관련된 많은 응용 프로그램이 존재하는 서비스가 있다고 가정해봅니다.
이러한 모든 시스템에는 자체적으로 주문 서비스(Order Service)가 존재합니다. 주문을 업데이트하는 프로세스에 특별한 비즈니스 로직이 필요할 경우 이러한 처리 로직을 모든 응용 프로그램에 복제해야 하며 추가 확인 및 조정이 필요합니다. 심지어 아래 그림의 경우 고유한 데이터베이스가 존재하므로 시스템의 순서가 현저하게 다를 수 있습니다.

SOA에서는 엔터프라이즈 레벨의 공유 서비스를 통해 이 문제를 해결하려고 합니다. 즉 아래 그림과 같이 (!! 그림 추가) 중앙에서 공유되는 Order Enterprise 서비스가 생성되면 모든 어플리케이션이 동일한 처리 로직을 공유 할 수 있습니다.

이제 Order 서비스는 공유괴지만 3개의 서로 다른 데이터베이스에 여전히 액세스를 하고 있습니다. "share-as-much-as-possible" 아키텍처 스타일이 사용 될 때 SOA에서 중요한 개념입니다. Order 서비스는 각 시스템의 주문 데이터를 검색하고 업데이트 하기 위해 어떤 데이터베이스를 사용할지 알 수 있을 만큼 충분히 스마트하며, 동시에 세 시스템간의 데이터를 동기화 합니다. 즉, 주문 순서는 하나의 데이터베이스가 아니라 세개의 데이터베이스를 조합하여 나타내게 됩니다.

이러한 개념은 비즈니스 기능의 중복과 관련된 문제를 해결하지만 긴밀하게 결합 된 구성 요소로 이어지는 경향이 있으며 변경과 관련된 전반적인 위험이 증가합니다. 예를 들어서 위의 그림에서 Order 서비스를 변경할 경우 해당 엔터프라이즈 서비스를 사용하는 모든 경우를 테스트하여야 하는데 이러한 작업은 수행하기가 힘듭니다.

마이크로서비스 아키텍처는 바운디드 컨텍스트라는 도메인 중심 디자인 개념을 활용합니다.
구조적으로 바운디드 컨텍스트는 최소 의존성을 가진 단일 폐쇄 단위로써 컴포넌트(서비스)와 관련 데이터의 결합을 의미합니다. 이러한 방식으로 설계된 서비스는 기본적으로 자체적으로 포함하고 있는 잘 정의된 인터페이스와 계약(contract)을 통해서만 노출 됩니다.

현실적으로, 마이크로서비스 아키텍처에서도 공유되는 일부 서비스가 항상 존재합니다.(예 : 인프라서비스)
그렇다고 해도 SOA는 구성요소를 최대한 공유하려는 반면 마이크로서비스는 바운디드 컨텍스트의 개념을 통해서 공유를 최소화 하려고 합니다.

바운디드 컨텍스트를 달성하고 종속성을 최소화하는 한가지 방법은 Do not Repeat Yourself(DRY) 원칙을 위반하고 서비스 전반에서 공통 기능을 복제하여 완전한 독립성을 달성하는 것입니다. 또 다른 방법은 상대적으로 정적인 모듈을 컴파일 타임 또는 런타임 바인딩에서 사용할 수 있는 공유 라이브러리로 컴파일 하는 것입니다.

바운디드 컨텍스트 개념을 활용할때 많은 장점이 존재합니다. 종속적인 모듈이 없기 때문에 서비스 유지보수가 훨씬 쉬워져 서비스가 다른 서비스와 독립적으로 변화하고 발전할 수 있습니다. 배포할 코드가 적고 한 모듈이나 서비스에 대한 변경이 다른 서비스에 영을 미칠 확률이 적기 때문에 배포가 쉽습니다. 이는 결국 서비스 변경에 따른 부작용이 적은 강력한 어플리케이션을 만들 수 있습니다.

### 3.2 Service Orchestration and Choreography (서비스 오케스트레이션 및 구성방법)

>> Choreography를 구성방법으로 번역하였습니다.

서비스 오케스트레이션과 서비스 구성방법의 차이는 명확하지 않습니다. 여기서는 오케스트레이션과 구성방법 간의 차이점과 이러한 서비스 커뮤니케이션 개념이 마이크로서비스와 SOA에서 어떻게 사용되는지에 대해서 설명합니다.

서비스 오케스트레이션이라는 용어는 서비스 소비자 또는 통합 허브(Mule, Camel, Spring Integration 등)와 같은 중앙 중개자를 통해 여러 서비스를 조정하는 것을 의미합니다. 아래 그림은 (!! 그림 추가) 서비스 오케스트레이션의 개념을 보여줍니다.

서비스 오케스트레이션에 대해 생각하는 쉬운 방법은 오케스트라에 대해서 생각합니다. 많은 음악가들이 서로 다른 시간에 다른 악기를 연주하지만, 모두 중심의 지휘자를 통해 조정됩니다. 마찬가지로 서비스 조정에서 중재자 구성 요소는 비즈니스 거래를 완료하는데 필요한 모든 서비스 요청을 조정하는 지휘자 역할을 수행합니다.

서비스 구성방법은 중앙 중개자가 없는 다중 서비스 호출의 조정을 나타냅니다. 서비스 간 통신이라는 용어는 때때로 서비스 구성방법과 관련하여 사용됩니다. 서비스 구성방법에서는 하나의 서비스가 다른 서비스를 호출하여 다른 서비스를 호출하는 등 서비스 체인이라고도 하는 작업을 수행합니다. 아래 그림을 참고 하십시오. (!! 그림 추가)

서비스 구성 방법에 대해 생각하는 한 가지 방법은 무대에서 공연하는 댄서들을 생각하는 것입니다. 모든 댄서들은 서로 동기화 되어서 움직이지만 누구도 지휘하거나 감독하지 않습니다. 즉 오케스트라는 한명의 지휘자에 의해 조정되지만, 춤은 개별 댄서를 통해서 완성 됩니다.


마이크로서비스 아키텍처는 서비스 오케스트레이션보다 서비스 구성방법을 선호합니다. 이유는 중앙 집중식 미들에어 구성요소가 없기 때문입니다.
아래 그림은 (!! 그림추가) 서비스 구성 요소와 선택사항인 API 계층의 두 가지 구성요소로만 구성 되는 것을 보여줍니다.

구현 관점에서 보면 서비스 등록 및 검색 구성 요소, 서비스 모니터링 및 배포 관리자와 같은 다른 구성 요소가 존재할 수 있지만 이들은 일반적으로 인프라 서비스로 분류가 됩니다.

마이크로서비스 아키텍처는 가능한 적게 공유하기 때문에 서비스와 인프라 서비스 간의 상호 작용을 제한해야 할 필요가 있습니다. 서비스 간 많은 조합이 필요하면 서비스가 너무 세밀하다는 이야기입니다.

마이크로서비스 아키텍처에서 서비스 구성방법이 지나치게 많으면 한 구성 요소가 단일 비즈니스 요청을 완료하기 위해 다른 서비스에 의존하는 결합도가 높아집니다. 아래의 그림의 예를 생각해보십시오. (!!그림 추가) 구조적으로, 이 비즈니스 요청은 높은 결합력을 가지게 되며 아키텍트는 이러한 문제를 최소화 하려고 노력해야 합니다.

서비스 구성방법내에서 이러한 커플링은 성능 저하 및 견고하지 않은 어플리케이션이 될 수 있습니다. 마이크로서비스 내에서 서비스간 호출은 전송 시간으로 인해 시간이 증가합니다. 더욱이 단일 비즈니스 요청에 대해 복수 서비스를 호출하게 되면 콜 체인의 특정 서비스를 사용할 수 없거나 응답하지 않을 확률이 높아져 안정성이 떨어지게 됩니다. 한가지 솔루션은 필요에 따라서 세분화된 서비스를 하나로 합치는 방법입니다.

아래 그림 (!!그림 추가)은 세 가지 세분화 된 서비스에서 하나의 서비스로 변경되는 방법입니다.
이렇게 하면 원격 호출이 적기 때문에 전체 성능이 향상됩니다. 그리고 서비스 가용성 문제가 줄어들기 때문에 전반적인 견고성이 향상 되며 서비스간 계약의 필요성을 제거하여 개발 및 유지 관리를 간소화 할 수 있습니다.

가능한 많이 공유하는 SOA는 비즈니스 요구를 처리하기 위해 서비스 오케스트레이션과 서비스 구성방법 모두에 의존하게 됩니다. 아래 그림 처럼(!!그림 추가) SOA의 메시징 미들웨어 구성 요소는 단일 비즈니스 서비스 요청을 기반으로 여러 엔터프라이즈 서비스를 호출하여 서비스를 오케스트레이션 합니다. 일단 엔터프라이즈 서비스에 있으면 서비스 구성방법을 사용하여 응용 프로그램 서비스 또는 인프라 서비스를 호출하여 특정 비즈니스 요청을 수행하는데 도움이 될 수 있습니다.

위 그림에서 서비스 구성방법과 관련하여 SOA내에서 발생할 수 있는 여러가지 방법을 보여줍니다. 예를 들어 엔터프라이즈 서비스는 어플리케이션 서비스를 호출하고 어플리케이션 서비스는 인프라 서비스를 호출해야 완성 될 수 있습니다. 또한 엔터프라이즈 서비스는 어플리케이션 서비스나 인프라 서비스를 직접 호출 할 수 있기도 하고 엔터프라이즈 서비스 내에 자체적으로 포함 될 수 있습니다. 마지막의 경우 서비스 구성방법이 필요하지 않습니다.

마이크로서비스와 SOA의 차이점은 성능, 개발, 테스트 및 배포를 비롯한 여러 부분에서 차이가 있습니다.
SOA는 일반적으로 단일 서비스 요청을 완료하기 위해 여러 서비스( 또는 서비스 유형)에 의존하기 때문에 마이크로서비스보다 속도가 느려지므로 개발, 테스트, 배치 및 유지 보수에 시간과 노력이 필요합니다. 이러한 요인들이 SOA에서 벗어나고 간단하고 능률적인 마이크로서비스 아키텍처 패턴으로 나아가는 요인중 하나입니다.

### 3.3 Middleware vs API Layer

위 그림에서 보여졌듯이 두 아키텍처 패턴 모두 중재를 처리하는 미들웨어 구성이 존재하였습니다. 마이크로서비스 아키텍처 패턴은 일반적으로 API 계층으로 알려져 있고 SOA는 메시징 미들웨어 구성 요소로 알려졌습니다.

마이크로서비스 패턴은 메시징 미들웨어(통합 허브 및 ESB)의 개념을 지원하지 않습니다. 오히려 서비스 액세스를 위한 API 레이어 개념을 지원합니다. 서비스 사용자가 서비스 엔드포인트의 실제 위치를 알 필요가 없도록 추상 레이어를 구성하기 때문에 이러한 API 레이어를 배치하는 것이 좋은 방법입니다. 그리고 서비스 사용자에게 영향을 미치지 않으면서 서비스의 세분화 수준을 변경할 수 있습니다.

예를 들어 제품 주문과 관련된 비즈니스 기능을 수행하는 서비스가 있다고 가정해보겠습니다. 배포를 용이하게 하기 위해 서비스를 두개의 세분화 된 서비스로 분할하려고 합니다. 실제 서비스 엔드 포인트를 추상화 하는 API 계층이 없으면 서비스를 사용하는 각 서비스 소비자는 두 개의 서비스를 호출하도록 수정 되어야 합니다. 하지만 API 계층을 사용하는 경우 서비스 소비자는 단일 요청이 이제 두개의 개별 서비스로 이동한다는 사실을 알지 못합니다.

SOA는 메시징 미들웨어를 사용하여 서비스 호출을 조정합니다. 메시징 미들웨어를 사용하면 중재 및 라우팅, 메시지 향상, 메시지 변환 및 프로토콜 변환을 포함하여 마이크로서비스 아키텍처 스타일에 없는 추가적인 기능이 제공 됩니다.

중개 및 라우팅은 아키텍처가 특정 비즈니스 또는 사용자 요청을 기반으로 서비스를 찾고 호출 할 수 있는 기능입니다.
아래 그림에서 (!! 그림 추가) 서비스 오케스트레이션 목적으로 서비스 레지스트리를 사용하였습니다. 마이크로서비스와 SOA는 이 기능을 사용합니다.

메시지 향상은 서비스가 도달하기 전에 요청의 데이터 부분을 수정, 제거 또는 보강하는 기능입니다. 예를 들어 날짜 형식 변경, 요청에서 파생 되거나 계산 된 값을 추가하는 행위가 있습니다. 마이크로 서비스 패턴은 미들웨어 구성 요소를 포함하지 않기 때문에 이 기능을 지원하지 않습니다. 반면 SOA는 메시징 미들웨어를 통해 이 기능을 완벽하게 지원합니다.

아래 그림에서 (!! 그림 추가) 서비스 사용자는 CUSIP 번호와 MM/DD/YY형식의 날짜를 전송하지만 서비스는 SEDOL 및 YYYY.MM.DD 형식의 날짜를 사용합니다. 이 경우 메시징 미들웨어는 서비스가 요청에 대한 값을 리턴 할 수 있도록 날짜와 번호를 변환하여 보냅니다.


메시지 변환은 한 형식에서 다른 형식으로 데이터 형식을 수정하는 기능을 나타냅니다. 예를 들어 아래 그림처럼 (!! 그림 추가) 서비스 사용자는 JSON 형식으로 서비스를 호출하고 데이터를 전송하는 반면 서비스는 Java 오브젝트를 필요로 합니다. 위에서 설명한 메시지 향상은 요청의 데이터에 관한 것이 아니라 데이터를 포함하는 래퍼 형식에 관한 것입니다.

마지막으로 프로토콜 변환은 서비스 소비자가 서비스가 기대하는 것과 다른 프로토콜을 사용하여 서비스를 호출하게 하는 기능입니다. 아래 그림에서 (!! 그림 추가) 서비스 사용자는 REST를 통해 통신하지만 요청을 처리하는 서비스는 RMI/IIOP 또는 AMQP를 사용합니다.


### 3.4 Accessing Remote Services

서비스는 보통 마이크로서비스와 SOA에서 원격으로 액세스 되기 때문에 이러한 아키텍처 패턴은 서비스 소비자가 원격 서비스에 액세스 할 수 있는 방법을 제공해야 합니다. 원격 액세스와 관련하여 마이크로 서비스와 SOA의 근본적인 차이점 중 하나는 마이크로서비스 아키텍처가 REST를 기본으로 하는 반면 SOA는 특별한 제한이 없다는 것입니다.

아키텍처 패턴의 단순성에 기여하는 마이크로서비스 기본 원리 중 하나는 기술 및 아키텍처 선택의 수가 몇 가지 옵션으로 제한 된다는 것입니다.
예를 들어, 대부분의 마이크로서비스 아키텍처는 두가지 프로토콜에 의존하는 경향이 있습니다.(REST와 AMQP 같은 간단한 메시징 프로토콜)
하지만 SOAP이나 .NET Remoting 과 같은 다른 원격 액세스 프로토콜을 활용 할 수 없다는 의미는 아닙니다.
중요한 점은 마이크로 서비스에서 발견되는 원격 액세스 프로토콜은 일반적으로 동일하다는 것입니다. REST기반, 메시징 기반 또는 다른 액세스 프로토콜로 구성 될 수 있지만 혼합되는 일은 드뭅니다. 한 가지 예외는 publish-and-subscribe 브로드캐스트 기능에 의존하는 서비스가 메시지 기반일 수 있는 반면 다른 비 브로드캐스트 서비스는 REST기반일 수 있습니다.

SOA는 어떤 원격 액세스 프로토콜을 사용할 수 있는지에 대한 제한이 ㅇ벗습니다. 즉 메시징 미들웨어에서 다른 프로토콜로 변환 할 수 있습니다. 일반적으로 SOA는 메시징 및 SOAP을 기본 서비스 원격 액세스 프로토콜로 사용합니다.


## 4. 아키텍처 기능 비교

아키텍처 패턴을 살펴보면 응용 프로그램이 확장 가능하고 유지보수가 가능하며 개발, 테스트 및 배포가 비교적 쉽다는 것을 확인 할 수 있습니다.
이 장에서는 각 아키텍처 패턴이 지원하는 어플리케이션 크기, 각 아키텍처 패턴을 사용하여 통합 할 수 있는 시스템과 컴포넌트 유형, 그리고 컨트랙트 디커플링을 지원하는 아키텍처 패턴의 능력 등데 초점을 맞춰서 마이크로서비스와 SOA를 비교합니다.

### 4.1 Application Scope

어플리케이션 번위는 아키텍처 패턴이 지원할 수 있는 어플리케이션의 전체 크기를 가르킵니다. 예를 들어서 마이크로 커널이나 파이프 라인 아키텍처와 같은 패턴은 소규모 응용프로그램이나 하위 시스템에 더 적합하지만 이벤트 기반 아키텍처와 같은 패턴은 복잡한 응용 프로그램에 적합합니다.

SOA는 다양한 이기종 응용 프로그램 및 서비스와의 통합이 필요한 크고 복잡한 엔터프라이즈급 시스템에 매우 적합합니다. 또한 많은 공유 구성 요소, 특히 기업 전체에서 공유되는 구성요소가 있는 응용 프로그램에 적합합니다. 따라서 SOA는 이기종 시스템 환경과 여러 어플리케이션 및 시스템 전반에 걸친 공통 서비스 공유로 인해 대형 보험 회사에 적합합니다.

그러나 잘 정의 된 처리 흐름을 갖고 있고 증권 거래와 같은 공유 구성 요소가 많지 않은 응용 프로그램은 SOA 아키텍처 패턴을 사용하여 구현하기가 힘듭니다. 소규모 웹 기반 어플리케이션 은 광범위한 서비스 분류, 추상화 레이어 및 메시징 미들웨어 구성 요소가 필요 없기 때문에 SOA에 적합하지 않습니다.

마이크로 서비스 패턴은 대규모 엔터프라이즈 급 시스템이 아니라 작고 잘 분할 된 웹 기반 시스템에 더 적합합니다. 메시징 미들웨어와 같은 중재자의 부재는 대규모 복합 어플리케이션 환경에 적합하지 않은 요소 중 하나입니다. 공유 요소가 없을 수록 마이크로서비스 패턴에 적합합니다.

어떤 경우에는 초기에 마이크로서비스 패턴을 선택할 수 있지만 비즈니스가 성장하고 성숙해짐에 따라 복잡한 요청(이기종 기능, 오케스트레이션 등)이 필요하기 시작합니다. 이러한 상황에서는 SOA 패턴으로 전환하여 초기 마이크로 서비스 아키텍처를 대체 할 수 있습니다. 물론, 그 반대의 경우도 존재합니다. SOA 아키텍처로 시작하였지만 기능들이 필요하지 않다면 마이크로서비스로 변경 할 수 있습니다.

### 4.2 Heterogeneous Interoperability (이기종 상호 운용성)

이기종 상호 운영성이란 다른 프로그래밍 언어와 플래폼으로 구현 된 시스템과 통합 할 수 있는 능력을 말합니다.
예를 들어, 하나의 복작합 비즈니스 요청이 Java 기반의 어플리케이션, .NET 기반 어플리케이션 등의 조합을 필요로 하는 상황이 있습니다.
이러한 예는 대기업에서 쉽게 찾아 볼 수 있습니다. 많은 은행 및 보험 시스템은 여전히 COBOL기반의 응용 프로그램에서 코어 처리를 가지고 있으며 이러한 서버는 현대적 웹 기반 플래폼에 의해 접근이 되어야 합니다. 이러한 이기종간의 통합 되는 능력은 마이크로서비스가 SOA에 비해 뒤쳐지는 몇 안되는 영역 중 하나입니다.

마이크로서비스 아키텍처 스타일은 서비스 통합을 위한 선택의 수를 줄임으로써 패턴과 구현을 단순화 하려고 합니다. REST와 간단한 메시징 프로토콜은 자주 사용 되는 프로토콜 중 두가지입니다. 하지만 SOA는 일반적으로 제한이 없고 메시징 미들웨어를 통해서 이 문제를 해결합니다.

마이크로서비스 서로 다른 기종을 지원하지만 통신은 동일해야 합니다. 즉, 서비스 사용자는 .NET으로 구성 되어 있지만 서비스는 Java로 구성 될 수 있습니다. 두 서비스간의 통신은 REST를 통해서 가능합니다. SOA의 경우 서비스 사용자가 SOAP으로 요청을 하고 서비스는 REST를 리턴한다고 하였을 때 메시징 미들웨어를 통해서 변환이 가능하지만 마이크로서비스는 메시징 미들웨어가 없기 때문에 아래 그림처럼(!!그림 추가) 동일한 통신방법을 이용해야 합니다.

반면 SOA는 아래 그림처럼 (!!그림 추가) 프로토콜에 독립적인 운용성으로 인해 서비스 소비자는 서비스의 구현뿐만 아니라 프로토콜에 대해서 무지해도 상관 없습니다.


다시한번 말하지만 마이크로서비스 아키텍처에는 메시징 미들웨어 구성요소에 대한 개념이 일반적으로 없기에 프로토콜에 구애받지 않는 이기종 간의 상호운용성 개념을 지원하지 않습니다.

만약 다른 프로토콜을 사용하여 여러 유형의 시스템이나 서비스를 통합해야 하는 경우 마이크로서비스보다는 SOA가 적합 할 수 있습니다.
하지만 동일한 원격 프로토콜(ex: REST)을 통해 모든 서비스를 공개하고 액세스 할 수 있다면 마이크로 서비스가 올바른 선택이 될 수 있습니다.

### 4.3 Contract Decoupling

컨트랙트 디커플링은 서비스 사용자와 서비스 간의 가장 높은 수준의 디커플링을 제공하는 강력한 기능입니다.
이 기능을 통해 서비스와 서비스 사용자는 서로간에 독립적으로 진화하면서 계약을 유지 할 수 있습니다. 또한 서비스 사용자가 소비자 주도형 계약을 사용하여 계약 변경을 유도 할 수 있게 함으로써 서비스와 서비스 사용자간에 보다 긴밀한 관계를 형성 할 수 있습니다.

컨트랙트 디커플링에는 메시지 변환과 메시지 향상의 두 가지 기본 형식이 있습니다.

* 메시지 변환 - 실제 요청 데이터가 아닌 메시지 형식에만 관련 됩니다. 예를 들어 XML입력형식으로 요구 할 수 있지만 서비스 소비자는 JSON 페이로드를 전송 할 수 있습니다. 이것은 대부분의 통합 허브에서 처리 할 수 있는 변환 작업입니다.

* 메시지 강화 - 메시지 변환이 요청 형식과 관련 되었다면 메시지 향상은 요청 데이터 그 자체와 관련이 있습니다. 일반적으로 미들웨어 구성요소가 요청 데이터를 추가하거나 변경하여 서비스가 요구하는 데이터와 일치시킵니다.

소비자가 아래와 같이 간단한 JSON객체로 서비스에게 요청 한다고 가정하겠습니다.

~~~json
{"trade": {
      "cust_id": "12345",
      "cusip": "037833100",
      "shares": "1000",
      "trade_dt": "10/12/15"
}}
~~~

반면 서비스는 아래와 같은 XML 데이터를 기대하고 있습니다.

~~~xml
<trade>
     <acct>321109</acct>
     <symbol>AAPL</symbol>
     <shares>1000</shares>
     <date>2015-10-12</date>
</trade>
~~~

서비스 사용자와 서비스 간의 계약 형식에 차이가 발생하면 정상적으로 작동하기 위해서 일반적으로 메시징 미들웨어나 클라이언트 어댑터가 데이터 변환 및 데이터 검색 기능을 수행합니다. 아래 그림을 참고 하십시오. (!! 그림 추가)

고객ID 및 CUSIP번호를 기반으로 하는 계정 번호르 얻기 위해 데이터베이스를 조회하고 날짜도 다른 형식으로 변환이 되며 변환할 필요가 없는 필드는 그대로 복사가 됩니다. 이를 통해 서비스 사용자는 서비스와 계약을 체결 할 수 있고 만약 계약 변경이 이루어지면 메시징 미들웨어를 통해 추상화 할 수 있습니다.

물론 이러한 방법에도 문제가 생길 수 있습니다. 서비스에서 필요로 하는 데이터가 다른 소스에서 파생 되거나 서비스 사용자가 제공한 데이터가 잘 못 되었을 경우 서비스 계약이 충족 되지 않아서 실패할 수 있습니다.

컨트랙트 디커플링을 이용하여 계약을 추상화하면 전체 비즈니스 응용 프로그램에 영향을 미치지 않고 기술을 변경 할 수 있습니다.
불행히도 마이크로서비스는 이 기능과 관련해서는 SOA에 비해서 아직 부족한 상태입니다. 따라서 아키텍처에서 이러한 추상화가 필요한 경우 SOA 솔루션을 고려해야 합니다.

## 5. Summary

마이크로서비스 아키텍처 패턴은 현재 새롭게 떠오르고 많이 사용 되고 있습니다. 마이크로서비스 패턴은 대규모 모놀로틱식 어플리케이션 및 복잡한 SOA 아키텍처에서 흔히 볼 수 있는 많은 문제를 해결하였지만 SOA보다 부족한 부분도 많습니다.(컨트랙트 디커플링 및 이기종 상호 운용성 등)

기억해야 할 기본 개념 중 하나는 마이크로서비스 아키텍처는 바운디드 컨텍스트 개념에 중점을 "share as little as possible"이라면 SOA는 "share as much as possible"이란 것입니다.
d
